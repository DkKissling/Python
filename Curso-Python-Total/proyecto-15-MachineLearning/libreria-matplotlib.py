# -*- coding: utf-8 -*-
"""Copia de Python TOTAL - Matplotlib.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ysEtaofyIAsHu00jFLqfYeLZFILYZLIf

# Práctica de la librería Matplotlib

En este notebook, se desarrollarán una serie de tareas utilizando la librería Matplotlib, empleada para la visualización de datos mediante gráficos.

Se proponen y documentan posibles formas de resolver los ejercicios, pero pueden existir varias formas de lograr los mismos resultados.

Siempre es una buena idea verificar la [Documentación Oficial de Matplotlib](https://matplotlib.org/stable/index.html), donde es posible encontrar todo tipo de información referida a esta librería. Y si te quedas trabado, busca en Google "como hacer [algo] con Matplotlib". Hay enormes probabilidades de que esa pregunta ya haya sido respondida!

Por ejemplo, si quieres crear un gráfico con `plt.subplots()`, puedes buscar directamente en Google [`plt.subplots()`](https://www.google.com/search?q=plt.subplots())
"""

# Commented out IPython magic to ensure Python compatibility.
# Importamos el módulo de Matplotlib como plt
import matplotlib.pyplot as plt
# La siguiente linea nos permite ver los gráficos directamente al ejecutarlos en el notebook
# %matplotlib inline

# Creamos un gráfico utilizando plt.plot()
plt.plot()

# Graficomos una lista de números
a=[1,2,5,6,8,10,15]
plt.plot(a)

# Creamos dos listas, x e y. Llenamos a la lista x de valores del 1 al 100.
x=list(range(1,101))

# Los valores de y van a equivaler al cuadrado del respectivo valor en x con el mísmo índice
y=[]
for i in x:
    y.append(i**2)

# Graficamos ambas listas creadas
plt.plot(x,y)

"""Hay otra manera de crear gráficos en Matplotlib, utilizando el método orientado a objetos (OO)."""

# Creamos el gráfico utilizando plt.subplots()
fig, ax = plt.subplots()
ax.plot(x,y)

"""Veamos cómo sería un flujo de trabajo en Matplotlib"""

# Commented out IPython magic to ensure Python compatibility.
# Importar y preparar la librería
import matplotlib.pyplot as plt
# %matplotlib inline

# Preparar los datos
x=list(range(1,101))
y=[]
for i in x:
    y.append(i**2)

# Crear el gráfico
fig, ax = plt.subplots()
ax.plot(x,y)
# Preparamos el área del gráfico (fig) y el gráfico en sí (ax) utilizando plt.subplots()
fig, ax = plt.subplots()

# Añadimos los datos al gráfico
ax.plot(x,y)

# Personalizamos el gráfico añadiendo título al gráfico y a los ejes x e y
ax.set_title("Gráfico de prueba")
ax.set_xlabel("Eje x")
ax.set_ylabel("Eje y")

# Guardamos nuestro gráfico empleando fig.savefig()
fig.savefig("prueba.png")

"""Veamos ahora un gráfico de dispersión:"""

#creamos un nuveo set de datos utilizando la librería
import numpy as np
x_1 = np.linspace(0, 100, 20)
y_1 = x_1**2

# Creamos el gráfico de dispersión de x vs y
fig, ax = plt.subplots()
ax.scatter(x_1, y_1)

# Visualizamos ahora la función seno, utilizando np.sin(X)
fig, ax = plt.subplots()

x_2 = np.linspace(-10, 10, 100)
y_2 = np.sin(x_2)

ax.scatter(x_2, y_2)

"""Veamos ahora otro tipo de gráfico. Por ejemplo, un gráfico de barras, que por lo general asocia resultados numéricos a variables categóricas (categorías)"""

# Creemos un diccionario con tres platos y su respectivo precio
# Las claves del diccionario serán los nombres de las comidas, y los valores asociados, su precio
comidas={'lasagna':350, 'sopa':150, 'roast beef':650}

# Crearemos un gráfico de barras donde el eje x está formado por las claves del diccionario,
# y el eje y contiene los valores.
fig, ax = plt.subplots()
ax.bar(comidas.keys(), comidas.values())

# Añadimos los títulos correspondientes
ax.set_title("Precio de tres comidas")
ax.set_xlabel("Comidas")
ax.set_ylabel("Precio")

# Probemos a continuación con un gráfico de barras horizontales
fig, ax = plt.subplots()
ax.barh(comidas.keys(), comidas.values())

"""Un gráfico semejante es un histograma. Podemos generar números aleatorios que siguen una distribución normal (que se acumulan en torno a un valor central), con la función randn:"""

# Creamos una distribución de 1000 valores aleatorios distribuidos normalmente
valores = np.random.randn(1000)

# Creamos el histograma
fig, ax = plt.subplots()
ax.hist(valores)

"""Veamos ahora un caso más complejo, trabajando con subplots, o figuras que cotienen varios gráficos:"""

# Creamos una figura con 4 subgráficos (2 por fila)
fig, axes = plt.subplots(2,2,figsize=(10,5))

"""Añadimos datos a cada uno de los gráficos (axes)"""

# Creamos la misma disposición de gráficos, con un tamaño de figura de 10x5
fig, ((ax1,ax2),(ax3,ax4)) = plt.subplots(nrows=2,ncols=2,figsize=(10,5))

# Para nuestro primer gráfico, tomamos el conjunto x_1, y_1, y generamos un gráfico de líneas
ax1.plot(x_1,y_1)

# Para nuestro segundo gráfico, tomamos el conjunto x_2, y_2, y generamos un gráfico de dispersión
ax2.scatter(x_2,y_2)


# Creamos un gráfico con los precios de tres comidas en la esquina inferior izquierda
ax3.bar(comidas.keys(), comidas.values())
ax3.set_title("Precio de tres comidas")
ax3.set_xlabel("Comidas")
ax3.set_ylabel("Precio")


# El gráfico de la esquina inferior derecha será un histograma de valores aleatorios con distribución normal
ax4.hist(valores)

"""Matplotlib tiene un conjunto de varios estilos disponibles, podemos verificarlos de la siguiente manera:"""

# Verificamos estilos disponibles
print(plt.style.available)

# Cambiamos el estilo predeterminado por "seaborn-whitegrid"
import seaborn as sns
sns.set_style("whitegrid")

"""Habiendo cambiado el estilo (el cambio más evidente que veremos será una grilla en el fondo de cada gráfico), cambiaremos también los colores de las líneas, puntos y barras en cada uno de los gráficos por códigos hex a nuestra preferencia:

"""

# Copiamos los valores de los gráficos anteriores
# Creamos la misma disposición de gráficos, con un tamaño de figura de 10x5
fig, ((ax1,ax2),(ax3,ax4)) = plt.subplots(nrows=2,ncols=2,figsize=(10,5))


# Para nuestro primer gráfico, tomamos el conjunto x_1, y_1, y generamos un gráfico de líneas
ax1.plot(x_1,y_1,color="#1f77b4")


# Para nuestro segundo gráfico, tomamos el conjunto x_2, y_2, y generamos un gráfico de dispersión
ax2.scatter(x_2,y_2,color="#ff7f0e")


# Creamos un gráfico con los precios de tres comidas en la esquina inferior izquierda
ax3.bar(comidas.keys(), comidas.values(),color="#2ca02c")


# El gráfico de la esquina inferior derecha será un histograma de valores aleatorios con distribución normal
ax4.hist(valores,color="#d62728")